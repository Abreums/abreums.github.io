---
title: "Linear Regression with tidymodels"
description: "Alguns exemplos de regressão linear em R e tidymodels"
date: 2019-02-25
author: 
  - name: Marcos Abreu
    url: https://abreums.github.io
    orcid: 0000-0003-4772-7955
citation:
  type: post-weblog
  url: https://abreums.github.io/posts/2023-01-25-linear-regression/
  language: pt-br
image: "forecasting_election_from_economy.png"
categories: [Rstat]
editor_options: 
  chunk_output_type: console
---

Minha recomendação para aprender sobre regressões é o livro [*Regression and Other Stories*](https://avehtari.github.io/ROS-Examples/index.html) que está disponível para download.     

Minha sugestão é que a leitura seja feita com os exemplos disponibilizados por [Bill Behrman](https://github.com/behrman/ros) utilizando tidyverse. 

Neste post e em posts futuros tentarei reproduzir os mesmos exemplos utilizando [tidymodels](https://www.tidymodels.org).

Para utilizar os exemplos de Bill Behrman precisa instalar o pacote *rosdata*, utilizando o comando:

> remotes::install_github("avehtari/ROS-Examples", subdir = "rpackage", force = TRUE)

O _help de *?rosdata* lista os vários conjuntos de dados disponíveis no pacote.

Vamos gerar um gráfico com as informações do conjunto *hibbs* que contém os dados dos percentuais de votos do candidato incumbente e da taxa de crescimento econômico do mesmo ano.

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false

# Packages
library(tidyverse)
library(rosdata)

```

Some data wrangling...

O base **hibbs** contém os votos do candidato do partido incumbente e a taxa de crescimento econômico médio da população. O que desejamos é verificar se existe uma relação entre a taxa de crescimento econômico e os votos do candidato do partido incumbente.

Vamos ajustar os dados para mostrar o ano, nome do candidato incumbente e nome do outro candidato em cada um dos pontos disponíveis.

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false
plot_data <- 
  hibbs %>% 
  mutate(
    label = str_glue("  {inc_party_candidate} vs. {other_candidate} ({year})  "),
    hjust = 
      if_else(
        year %in% c(1960, 1964, 1972, 1976, 1984, 1996, 2012),
        "right",
        "left"
      ),
    vjust =
      case_when(
        year == 1992 ~ 0,
        year == 2000 ~ 0.2,
        year %in% c(1960, 2008) ~ 1,
        TRUE ~ 0.5
      )
  ) |> as_tibble()

```

Printing a scatter plot:

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false
my_plot <- 
  plot_data |> 
  ggplot(aes(growth, vote)) +
  geom_hline(yintercept = 50, color = "lightgrey") +
  geom_point()  +
  geom_text(aes(label = label, hjust = hjust, vjust = vjust)) +
  labs(
    title = "Forecasting the election from economy",
    x = "Average recent growth in personal income",
    y = "Incumbent party's vote share"
  ) +
  scale_x_continuous(labels = scales::label_percent(accuracy = 1, scale = 1),
                     expand = expansion(add = c(0.8, 1.2))) +
  scale_y_continuous(labels = scales::label_percent(accuracy = 1, scale = 1)) +
  theme_minimal()
my_plot
```

No livro [*Regression and Other Stories*](https://avehtari.github.io/ROS-Examples/index.html) os autores fazem uma regressão linear com os dados utilizando *stan_glm*.

*stan_glm* pertence ao pacote [rtanarm](https://mc-stan.org/rstanarm/index.html) e realiza a regressão linear utilizando inferência Bayesiana. Não é preciso entender como isto funciona neste post (pretendo escrever um post futuro sobre este pacote). O importante aqui é saber que esta função realiza a regressão linear através de uma técnica específica. 

Para fazer a regressão linear os autores sugerem:

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false

library(rstanarm)
set.seed(264)

fit_stan <- stan_glm(vote ~ growth, data = hibbs, refresh = 0)
fit_stan

## Print summary of the prior used:
# prior_summary(fit)
# summary(fit)

```

Os resultados da regressão mostram uma reta *y = ax + b* determinada pelos parâmetros *a = 3.1* e *b = 46.3*.

Podemos acrescentar esta reta no nosso gráfico anterior.

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false

my_plot +
  geom_abline(slope = 3.1, intercept = 46.3, color = "#FF6788")
```

Ao contrário dos autores, vamos fazer a mesma regressão, porém, utilizando o pacote tidymodels.

Num primeiro momento o uso de *tidymodels* pode parecer mais burocrático, mas veremos que há vantagens em utilizar este modo de implementar regressões.

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false
library(tidymodels)

# Primeiro passo é definir um modelo
lm_spec <- linear_reg() %>%
  set_mode("regression") %>%
  set_engine("stan")

# Segundo passo é ajustar o modelo
lm_fit <- fit(lm_spec, vote ~ growth, data = hibbs)
lm_fit
```

Ao invés de simplesmente chamar a função _stan_glm_ fizemos um monte de coisas. E qual a vantagem disto tudo ao invés de chamar o método diretamente.

A vantagem aparece nos casos onde queremos obter padronização para diferentes métodos de regressão (veremos em outro post como isto pode ser útil, por enquanto vamos entender os conceitos do **tidymodels**).

Quem faz tudo isto é o pacote [parsnip](https://parsnip.tidymodels.org/index.html) que faz parte do **tidymodels**. A finalidade do parsnip é separar a definição do modelo do processo de cálculo da regressão:
  - Quando escrevemos **linear_reg()** estamos definindo o **tipo** do modelo (um tipo diferente seria, por exemplo, um random forest: _rand_forest()_).
  - **set_mode()** define o tipo de modelagem que será feita - as opções são tipicamente "classificatin" ou "regression".
  - e finalmente **set_engine()** recebe como parâmetro o nome do pacote que contém o motor que será utilizado para executar o modelo.
  
Por sua fez, a função **fit()** calcula/ajusta o modelo conforme os parâmetros passados para ela.Este [link](https://diamondage.com/what-does-it-mean-to-fit-a-model-anyway/) contém uma boa explicação do que significa "ajustar" o modelo.

Veremos em posts futuros que esta forma onde separamos a definição do cálculo em si é útil em diversas situações.

Por fim, o pacote **broom** contém a função _tidy()_ que permite retornar os parâmetros calculados do modelo num formato "tidy" (especificamente para modelos do pacote _rstanarm_ temos que utilizar o método _tidy()_ do pacote _broom.mixed_).

Isto nos permite ajustar o gráfico anterior de uma forma mais sistemática sem precisar copiar manualmente os valores dos parâmetros da regressão.

```{r}
#| echo: fenced
#| warning: false
#| error: false
#| message: false


tidy_terms <- broom.mixed::tidy(lm_fit)
tidy_terms
my_plot +
  geom_abline(intercept = tidy_terms$estimate[tidy_terms$term == "(Intercept)"],
              slope = tidy_terms$estimate[tidy_terms$term == "growth"],
              color = "#FF9977")
```

## Conclusão

Neste post temos o exemplo do capítulo 1 do livro [*Regression and Other Stories*](https://avehtari.github.io/ROS-Examples/index.html) implementado utilizando **tidymodels**:
  - tidymodels separa a definição do modelo de seu cálculo (pacote _parsnip_):
    - definição do modelo: _linear_reg()_
    - definição do modo do modelo: _set_mode("regression")_
    - definição do motor/algoritmo que será utilizado: _set_engine("stan")_
    - cálculo do modelo: _fit(...)_
  - tidymodels permite acessar os resultados da regressão num formato tidy (pacote _broom_):
    - _tidy(lm_fit)_
    
  
