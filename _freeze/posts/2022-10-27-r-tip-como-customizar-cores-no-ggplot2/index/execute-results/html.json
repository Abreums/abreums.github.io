{
  "hash": "4f405134b4b054ec5e7fa11e2ce2f266",
  "result": {
    "markdown": "---\ntitle: \"R tip: Como customizar cores no ggplot2\"\ndescription: \"Rstat - uso do ggplot2 com paletas de cores customizadas para variáveis discretas e contínuas nas estéticas colour e fill.\"\ndate: 2022-10-27\nauthor: \n  - name: Marcos Abreu\n    url: https://abreums.github.io\n    orcid: 0000-0003-4772-7955\ncitation:\n  type: post-weblog\n  url: https://abreums.github.io/posts/2022-10-27-r-tip-como-customizar-cores-no-ggplot2/\n  language: pt-br\nbibliography: \"https://api.citedrive.com/bib/092b439a-22cd-422b-9913-a61b66c8505d/references.bib?x=eyJpZCI6ICIwOTJiNDM5YS0yMmNkLTQyMmItOTkxMy1hNjFiNjZjODUwNWQiLCAidXNlciI6ICI4MjAiLCAic2lnbmF0dXJlIjogImNlMjYyNmViZmU5MjJlYTcyYmM2YjViOWZkMmE4ZDA0ZWIxMjRiYzA3M2RhY2RlNmUwNzJjODljNmY4ZWY3ZWMifQ==/bibliography.bib\"\ncategories: [Rstat]\n---\n\n\nSeguindo a regra de que se vc tiver que explicar alguma coisa mais de 3 vezes, então você deve escrever um post sobre o assunto. E considerando que neste caso, estou explicando para mim mesmo como definir cores no ggplo2, achei melhor escrever este post para me ajudar a lembrar destas informações na próxima vez que precisar delas.\n\nPara escrever este post utilizei as seguintes referências: [@Garrickadenbuie2019Custom:9540], [@Simonjackson2018Creating:2c49] e [@Meghanhall2022Creating:40ec].\n\nEstou usando este [site](https://htmlcolorcodes.com) para buscar os códigos das cores. Vou utilizar a seguintes cores:\n\n![Paleta de Cores](./palette1.png){#fig-palette1}\n\n## Definindo funções para lidar com cores\n\nVamos definir uma função para lidar com as cores que desejamos.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nminhas_cores <- function(...) {\n  cores <- c(\n    \"laranja\" = \"#e59866\",\n    \"cinza\" = \"#979a9a\",\n    \"azul\" = \"#1b2631\",\n    \"vermelho\" = \"#641e16\",\n    \"agua\" = \"#d1f2eb\",\n    \"amarelo\" = \"#fcf3cf\"\n  )\n  cols <- c(...)\n  \n  if (is.null(cols))\n    return (cores)\n  \n  cores[cols]\n}\n```\n````\n:::\n\n\nA função acima permite acesso às cores:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nminhas_cores(\"vermelho\", \"amarelo\")\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n vermelho   amarelo \n\"#641e16\" \"#fcf3cf\" \n```\n:::\n:::\n\n\nPodemos criar conjuntos diferentes de paletas de cores a partir das cores definidas na função *minhas_cores*.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nminhas_paletas <- function(palette = \"main\", ...) {\n  minhas_paletas <- list(\n    \"main\" = minhas_cores(\"laranja\", \"cinza\", \"vermelho\", \"amarelo\"),\n    \"highlight\" = minhas_cores(\"agua\", \"azul\", \"amarelo\"),\n    \"two_colors\" = minhas_cores(\"laranja\", \"vermelho\")\n  )\n  minhas_paletas[[palette]]\n}\n```\n````\n:::\n\n\nIsto permite selecionar um subgrupo de cores:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nminhas_paletas(\"main\")\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n  laranja     cinza  vermelho   amarelo \n\"#e59866\" \"#979a9a\" \"#641e16\" \"#fcf3cf\" \n```\n:::\n:::\n\n\nPodemos usar a função *scales::show_col* para mostrar as cores de uma forma elegante:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"paleta Main\"\n#| label: fig-main-palette\n\nscales::show_col(minhas_paletas(\"main\"), cex_label = 2)\n```\n````\n\n::: {.cell-output-display}\n![paleta Main](index_files/figure-html/fig-main-palette-1.png){#fig-main-palette width=672}\n:::\n:::\n\n\n## Usando as cores\n\nVamos utilizar as cores de @fig-main-palette em alguns gráficos.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| message: false\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n```\n````\n:::\n\n\nPodemos referenciar as cores com a função *minhas_cores* definida anteriormente. Aqui, utilizamos o atributo *fill* de *geom_col* para definir a cor de preenchimento das barras do gráfico.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Barras preenchidas por cor selecionada\"\n#| label: fig-pn-1\n\npenguins <- palmerpenguins::penguins\n\npenguins %>% \n  count(species) %>% \n  ggplot(aes(x = species, y = n)) +\n  geom_col(fill = minhas_cores(\"laranja\")) +\n  labs(title = \"Contagem de espécies\") +\n  scale_y_continuous(expand = expansion(mult = c(0,0.1))) + # aumenta em 10% o eixo y positivo \n  theme_linedraw() +\n  theme(axis.ticks = element_blank(), \n        axis.title = element_blank(),\n        panel.grid.major.x = element_blank())\n```\n````\n\n::: {.cell-output-display}\n![Barras preenchidas por cor selecionada](index_files/figure-html/fig-pn-1-1.png){#fig-pn-1 width=672}\n:::\n:::\n\n\nAtravés da função *scale_fill_manual* podemos usar diferentes cores para cada espécie de pinguim.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Cores das barras atribuídas pela ordem alfabética das espécies\"\n#| label: fig-pn-2\n\npenguins %>%\n  count(species) %>% \n  ggplot(aes(x = species, y = n, fill = species)) + \n  geom_col() +\n  scale_fill_manual(values = unname(c(minhas_cores(\"laranja\", \"azul\", \"vermelho\")))) +\n  labs(title = \"Contagem de espécies\") +\n  scale_y_continuous(expand = expansion(mult = c(0,0.1))) +\n  theme_linedraw() +\n  theme(axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid.major.x = element_blank())\n```\n````\n\n::: {.cell-output-display}\n![Cores das barras atribuídas pela ordem alfabética das espécies](index_files/figure-html/fig-pn-2-1.png){#fig-pn-2 width=672}\n:::\n:::\n\n\nNo caso anterior as cores de cada espécie ficam dependentes da sequência com que as espécies são apresentadas - ordem alfabética - e da sequência das cores. Em alguns casos, gostaríamos que as cores ficassem atreladas às espécies específicas e não mudassem conforme a ordem dos atributos (o que é muito útil quando temos muitos gráficos) com os mesmos dados. Para isso, podemos associar cores às espécies nomeando um vetor com os nomes das espécies e os códigos das cores.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Vetor nomeado de cores\"\n#| label: fig-named-colors\n\npenguins_colors <- minhas_cores(\"laranja\", \"azul\", \"vermelho\")\npenguins_colors <- setNames(penguins_colors, c(\"Gentoo\", \"Chinstrap\", \"Adelie\"))\npenguins_colors\nscales::show_col(penguins_colors, cex_label = 2)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n   Gentoo Chinstrap    Adelie \n\"#e59866\" \"#1b2631\" \"#641e16\" \n```\n:::\n\n::: {.cell-output-display}\n![Vetor nomeado de cores](index_files/figure-html/fig-named-colors-1.png){#fig-named-colors width=672}\n:::\n:::\n\n\ne utilizar este array da @fig-named-colors com a função *scale_fill_manual*. As cores são atribuídas conforme nomeamos cada elemento do vetor de cores (por exemplo, \"Adele = #641e16 (vermelho)\". Se não tivéssemos feito isso, o sistema primeiro atribuiria as cores conforme a ordem alfabética como no código anterior e depois montaria o gráfico conforme a ordenação do *fct_reorder*.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Usando o vetor nomeado\"\n#| label: fig-vetor-nomeado\n\npenguins %>% \n  count(species) %>% \n  ggplot(aes(x = fct_reorder(species, desc(n)), y = n, fill = species)) +\n  geom_col() +\n  scale_fill_manual(values = penguins_colors) +\n  labs(title = \"Contagem de espécies\") +\n  scale_y_continuous(expand = expansion(mult = c(0,0.1))) +\n  theme_linedraw() +\n  theme(axis.ticks = element_blank(),\n        axis.title = element_blank(),\n        panel.grid.major.x = element_blank())\n```\n````\n\n::: {.cell-output-display}\n![Usando o vetor nomeado](index_files/figure-html/fig-vetor-nomeado-1.png){#fig-vetor-nomeado width=672}\n:::\n:::\n\n\nEm alguns gráficos pode ser necessário termos mais cores do que as disponíveis na paleta de cores. É possível gerar novas paletas com um número maior de cores por interpolação através da função *colorRampPalette*. A função *colorRampPalette* devolve uma função para a qual passaremos o número de cores que gostaríamos de gerar a partir da interpolação das cores da paleta fornecida.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Usando _colorRampPalette_ para gerar paletas de cores maiores\"\n#| label: fig-pal-12\n\npenguins_12_colors <- colorRampPalette(minhas_paletas(\"highlight\"))(12)\n\nscales::show_col(penguins_12_colors, cex_label = 1)\n```\n````\n\n::: {.cell-output-display}\n![Usando _colorRampPalette_ para gerar paletas de cores maiores](index_files/figure-html/fig-pal-12-1.png){#fig-pal-12 width=672}\n:::\n:::\n\n\nVamos colocar isto em uma função e testar.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Função que devolve função para gerar cores\"\n#| label: fig-gera-cores\n\npenguin_pal <- function(palette = \"main\", reverse = FALSE, ...) {\n  pal <- minhas_paletas(palette)\n\n  if (reverse) pal <- rev(pal)\n\n  colorRampPalette(pal, ...)\n}\nscales::show_col(penguin_pal(palette = \"two_colors\", reverse = TRUE)(12))\n```\n````\n\n::: {.cell-output-display}\n![Função que devolve função para gerar cores](index_files/figure-html/fig-gera-cores-1.png){#fig-gera-cores width=672}\n:::\n:::\n\n\nConsidere o seguinte gráfico que usa uma escala contínua de cores:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Diagrama de dispersão\"\n#| label: fig-scatter1\npenguins %>% \n  filter(!is.na(bill_length_mm),\n         !is.na(bill_depth_mm)) %>% \n  ggplot(aes(bill_length_mm, bill_depth_mm, color = flipper_length_mm)) +\n  geom_point() \n```\n````\n\n::: {.cell-output-display}\n![Diagrama de dispersão](index_files/figure-html/fig-scatter1-1.png){#fig-scatter1 width=672}\n:::\n:::\n\n\nGostaríamos de modificar a escala de cores utilizando as cores previamente definidas em *minhas_cores* e *minhas_paletas*.\n\nPrimeiro precisamos definir uma função que cria uma customização da função *scale_color_continuous*.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#' Construtor de cores para escala contínua.\n#'\n#' @param palette nome da paleta definida em minhas_paletas\n#' @param discrete Boolean indica se \"color aesthetic\" é discreto ou não\n#' @param reverse Boolean indica se a paleta deve ter a sequência de cores invertida\n#' @param ... outros parâmetros que serão passados para discrete_scale() ou\n#'            scale_color_gradientn(), uma das duas funções conforme o discrete é TRUE ou FALSE\n#'\nscale_color_penguin <- function(palette = \"main\", discrete = TRUE, reverse = FALSE, ...) {\n  pal <- penguin_pal(palette = palette, reverse = reverse)\n\n  if (discrete) {\n    discrete_scale(\"colour\", paste0(\"penguin_\", palette), palette = pal, ...)\n  } else {\n    scale_color_gradientn(colours = pal(256), ...)\n  }\n}\n\nscale_color_penguin(palette = \"highlight\", discrete = FALSE)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n<ScaleContinuous>\n Range:  \n Limits:    0 --    1\n```\n:::\n:::\n\n\nVamos ajustar o último gráfico que fizemos para utilizar uma paleta de cores baseada na *minhas_paletas*(\"highlight\").\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Escala de cores customizada gerada a partir da paleta específica\"\n#| label: fig-scatter-2\n\npenguins %>% \n  filter(!is.na(bill_length_mm),\n         !is.na(bill_depth_mm)) %>% \n  ggplot(aes(bill_length_mm, bill_depth_mm, color = flipper_length_mm)) +\n  geom_point() +\n  scale_color_penguin(\"two_colors\", discrete = FALSE)\n```\n````\n\n::: {.cell-output-display}\n![Escala de cores customizada gerada a partir da paleta específica](index_files/figure-html/fig-scatter-2-1.png){#fig-scatter-2 width=672}\n:::\n:::\n\n\nDe forma similar à função *color* que fizemos, podemos implementar uma função para *fill*:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#' Construtor de cores para escala contínua.\n#'\n#' @param palette nome da paleta definida em minhas_paletas\n#' @param discrete Boolean indica se \"color aesthetic\" é discreto ou não\n#' @param reverse Boolean indica se a paleta deve ter a sequência de cores invertida\n#' @param ... outros parâmetros que serão passados para discrete_scale() ou\n#'            scale_color_gradientn(), uma das duas funções conforme o discrete é TRUE ou FALSE\n#'\nscale_fill_penguin <- function(palette = \"main\", discrete = TRUE, reverse = FALSE, ...) {\n  pal <- penguin_pal(palette = palette, reverse = reverse)\n\n  if (discrete) {\n    discrete_scale(\"fill\", paste0(\"penguin_\", palette), palette = pal, ...)\n  } else {\n    scale_fill_gradientn(colours = pal(256), ...)\n  }\n}\n```\n````\n:::\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-cap: \"Cores de preenchimento geradas a partir de paleta específica\"\n#| label: fig-barchart\n\npenguins %>% \n   filter(!is.na(bill_length_mm),\n         !is.na(bill_depth_mm)) %>% \n  ggplot(aes(bill_length_mm, bill_depth_mm, color = flipper_length_mm)) +\n  geom_col() +\n  scale_color_penguin(\"two_colors\", discrete = FALSE)\n```\n````\n\n::: {.cell-output-display}\n![Cores de preenchimento geradas a partir de paleta específica](index_files/figure-html/fig-barchart-1.png){#fig-barchart width=672}\n:::\n:::\n\n\nEste último gráfico não faz muito sentido, mas está aí apenas para exemplificar o uso da função *scale_fill_penguin*.\n\n### Referências\n\n::: {#refs}\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}