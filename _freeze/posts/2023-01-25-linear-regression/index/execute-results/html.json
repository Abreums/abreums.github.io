{
  "hash": "68ce402dd694e101a2c9795ec734781d",
  "result": {
    "markdown": "---\ntitle: \"Linear Regression with tidymodels\"\ndescription: \"Alguns exemplos de regressão linear em R e tidymodels\"\ndate: 2023-01-25\nauthor: \n  - name: Marcos Abreu\n    url: https://abreums.github.io\n    orcid: 0000-0003-4772-7955\ncitation:\n  type: post-weblog\n  url: https://abreums.github.io/posts/2023-01-25-linear-regression/\n  language: pt-br\nimage: \"forecasting_election_from_economy.png\"\ncategories: [Rstat]\neditor_options: \n  chunk_output_type: console\n---\n\n\nMinha recomendação para aprender sobre regressões é o livro [*Regression and Other Stories*](https://avehtari.github.io/ROS-Examples/index.html) que está disponível para download.     \n\nMinha sugestão é que a leitura seja feita com os exemplos disponibilizados por [Bill Behrman](https://github.com/behrman/ros) utilizando tidyverse. \n\nNeste post e em posts futuros tentarei reproduzir os mesmos exemplos utilizando [tidymodels](https://www.tidymodels.org).\n\nPara utilizar os exemplos de Bill Behrman precisa instalar o pacote *rosdata*, utilizando o comando:\n\n> remotes::install_github(\"avehtari/ROS-Examples\", subdir = \"rpackage\", force = TRUE)\n\nO _help de *?rosdata* lista os vários conjuntos de dados disponíveis no pacote.\n\nVamos gerar um gráfico com as informações do conjunto *hibbs* que contém os dados dos percentuais de votos do candidato incumbente e da taxa de crescimento econômico do mesmo ano.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\n\n# Packages\nlibrary(tidyverse)\nlibrary(rosdata)\n```\n````\n:::\n\n\nSome data wrangling...\n\nO base **hibbs** contém os votos do candidato do partido incumbente e a taxa de crescimento econômico médio da população. O que desejamos é verificar se existe uma relação entre a taxa de crescimento econômico e os votos do candidato do partido incumbente.\n\nVamos ajustar os dados para mostrar o ano, nome do candidato incumbente e nome do outro candidato em cada um dos pontos disponíveis.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\nplot_data <- \n  hibbs %>% \n  mutate(\n    label = str_glue(\"  {inc_party_candidate} vs. {other_candidate} ({year})  \"),\n    hjust = \n      if_else(\n        year %in% c(1960, 1964, 1972, 1976, 1984, 1996, 2012),\n        \"right\",\n        \"left\"\n      ),\n    vjust =\n      case_when(\n        year == 1992 ~ 0,\n        year == 2000 ~ 0.2,\n        year %in% c(1960, 2008) ~ 1,\n        TRUE ~ 0.5\n      )\n  ) |> as_tibble()\n```\n````\n:::\n\n\nPrinting a scatter plot:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\nmy_plot <- \n  plot_data |> \n  ggplot(aes(growth, vote)) +\n  geom_hline(yintercept = 50, color = \"lightgrey\") +\n  geom_point()  +\n  geom_text(aes(label = label, hjust = hjust, vjust = vjust)) +\n  labs(\n    title = \"Forecasting the election from economy\",\n    x = \"Average recent growth in personal income\",\n    y = \"Incumbent party's vote share\"\n  ) +\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1, scale = 1),\n                     expand = expansion(add = c(0.8, 1.2))) +\n  scale_y_continuous(labels = scales::label_percent(accuracy = 1, scale = 1)) +\n  theme_minimal()\nmy_plot\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nNo livro [*Regression and Other Stories*](https://avehtari.github.io/ROS-Examples/index.html) os autores fazem uma regressão linear com os dados utilizando *stan_glm*.\n\n*stan_glm* pertence ao pacote [rtanarm](https://mc-stan.org/rstanarm/index.html) e realiza a regressão linear utilizando inferência Bayesiana. Não é preciso entender como isto funciona neste post (pretendo escrever um post futuro sobre este pacote). O importante aqui é saber que esta função realiza a regressão linear através de uma técnica específica. \n\nPara fazer a regressão linear os autores sugerem:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\n\nlibrary(rstanarm)\nset.seed(264)\n\nfit_stan <- stan_glm(vote ~ growth, data = hibbs, refresh = 0)\nfit_stan\n\n## Print summary of the prior used:\n# prior_summary(fit)\n# summary(fit)\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\nstan_glm\n family:       gaussian [identity]\n formula:      vote ~ growth\n observations: 16\n predictors:   2\n------\n            Median MAD_SD\n(Intercept) 46.3    1.7  \ngrowth       3.1    0.7  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 3.9    0.7   \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n```\n:::\n:::\n\n\nOs resultados da regressão mostram uma reta *y = ax + b* determinada pelos parâmetros *a = 3.1* e *b = 46.3*.\n\nPodemos acrescentar esta reta no nosso gráfico anterior.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\n\nmy_plot +\n  geom_abline(slope = 3.1, intercept = 46.3, color = \"#FF6788\")\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nAo contrário dos autores, vamos fazer a mesma regressão, porém, utilizando o pacote tidymodels.\n\nNum primeiro momento o uso de *tidymodels* pode parecer mais burocrático, mas veremos que há vantagens em utilizar este modo de implementar regressões.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\nlibrary(tidymodels)\n\n# Primeiro passo é definir um modelo\nlm_spec <- linear_reg() %>%\n  set_mode(\"regression\") %>%\n  set_engine(\"stan\")\n\n# Segundo passo é ajustar o modelo\nlm_fit <- fit(lm_spec, vote ~ growth, data = hibbs)\nlm_fit\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\nparsnip model object\n\nstan_glm\n family:       gaussian [identity]\n formula:      vote ~ growth\n observations: 16\n predictors:   2\n------\n            Median MAD_SD\n(Intercept) 46.3    1.7  \ngrowth       3.1    0.7  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 3.9    0.7   \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n```\n:::\n:::\n\n\nAo invés de simplesmente chamar a função _stan_glm_ fizemos um monte de coisas. E qual a vantagem disto tudo ao invés de chamar o método diretamente.\n\nA vantagem aparece nos casos onde queremos obter padronização para diferentes métodos de regressão (veremos em outro post como isto pode ser útil, por enquanto vamos entender os conceitos do **tidymodels**).\n\nQuem faz tudo isto é o pacote [parsnip](https://parsnip.tidymodels.org/index.html) que faz parte do **tidymodels**. A finalidade do parsnip é separar a definição do modelo do processo de cálculo da regressão:\n  - Quando escrevemos **linear_reg()** estamos definindo o **tipo** do modelo (um tipo diferente seria, por exemplo, um random forest: _rand_forest()_).\n  - **set_mode()** define o tipo de modelagem que será feita - as opções são tipicamente \"classificatin\" ou \"regression\".\n  - e finalmente **set_engine()** recebe como parâmetro o nome do pacote que contém o motor que será utilizado para executar o modelo.\n  \nPor sua fez, a função **fit()** calcula/ajusta o modelo conforme os parâmetros passados para ela.Este [link](https://diamondage.com/what-does-it-mean-to-fit-a-model-anyway/) contém uma boa explicação do que significa \"ajustar\" o modelo.\n\nVeremos em posts futuros que esta forma onde separamos a definição do cálculo em si é útil em diversas situações.\n\nPor fim, o pacote **broom** contém a função _tidy()_ que permite retornar os parâmetros calculados do modelo num formato \"tidy\" (especificamente para modelos do pacote _rstanarm_ temos que utilizar o método _tidy()_ do pacote _broom.mixed_).\n\nIsto nos permite ajustar o gráfico anterior de uma forma mais sistemática sem precisar copiar manualmente os valores dos parâmetros da regressão.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| warning: false\n#| error: false\n#| message: false\n\ntidy_terms <- broom.mixed::tidy(lm_fit)\ntidy_terms\nmy_plot +\n  geom_abline(intercept = tidy_terms$estimate[tidy_terms$term == \"(Intercept)\"],\n              slope = tidy_terms$estimate[tidy_terms$term == \"growth\"],\n              color = \"#FF9977\")\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 3\n  term        estimate std.error\n  <chr>          <dbl>     <dbl>\n1 (Intercept)    46.3      1.68 \n2 growth          3.07     0.699\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Conclusão\n\nNeste post temos o exemplo do capítulo 1 do livro [*Regression and Other Stories*](https://avehtari.github.io/ROS-Examples/index.html) implementado utilizando **tidymodels**:\n  - tidymodels separa a definição do modelo de seu cálculo (pacote _parsnip_):\n    - definição do modelo: _linear_reg()_\n    - definição do modo do modelo: _set_mode(\"regression\")_\n    - definição do motor/algoritmo que será utilizado: _set_engine(\"stan\")_\n    - cálculo do modelo: _fit(...)_\n  - tidymodels permite acessar os resultados da regressão num formato tidy (pacote _broom_):\n    - _tidy(lm_fit)_\n    \n  \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}